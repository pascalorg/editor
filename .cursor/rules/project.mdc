---
alwaysApply: true
---

# Building Editor - Project Documentation

## 1. Overview

3D building/floor plan editor built with Next.js, React Three Fiber, and Zustand. Users create multi-floor layouts by placing walls/doors/windows/roofs on a grid, similar to The Sims build mode. Includes a read-only **Viewer mode** for presentation.

## 2. Technology Stack

- **Core**: Next.js 16 (App Router), React 19, TypeScript, Bun.
- **3D**: Three.js, React Three Fiber (R3F), @react-three/drei, @react-spring/three.
- **State**: Zustand (with localStorage & IndexedDB persistence), Immer.
- **UI**: Tailwind CSS 4, Shadcn UI, Radix UI, Lucide/Phosphor Icons.
- **Dev Tools**: Biome (linting/formatting), React Scan.

## 3. Architecture & Core Systems

### Scene Graph (`@lib/scenegraph`)
The project leverages a strict node-based architecture.
- **Schema**: Zod schemas definition (`lib/scenegraph/schema`).
- **Hierarchy**: `Root` -> `Site` -> `Building` -> `Level` -> `Nodes` (Wall, Slab, etc.).
- **SceneGraph Class**: Wraps raw JSON state, provides O(1) indexing (`byId`, `byType`, `byLevel`), and returns `SceneNodeHandle` objects for safe interaction.

### Node Registry (`@lib/nodes/registry.ts`)
Connects the data model to the UI. Each node type registers:
- **Schema**: Data validation.
- **Editor Component**: Logic for creation/manipulation (handles grid events).
- **Renderer Component**: 3D visual representation.
- **Metadata**: Name, tool icon, editor mode.

### State Management (`hooks/use-editor.tsx`)
Single source of truth using Zustand.
- **Store**: Holds the `SceneGraph` instance.
- **Mutations**: Performed via `CommandManager` (Undo/Redo support) or direct updates for previews.
- **Persistence**: Auto-syncs to localStorage; heavy assets (images) use IndexedDB.

### Grid System
- **Discrete Intersection**: 61x61 points, 50cm spacing.
- **Coordinates**: Grid coordinates (int) map to World coordinates (float). Grid Y → World Z.
- **Interaction**: Raycasting from camera to a single interactive plane. Smart snapping to H/V/45° axes.

### Wall Geometry
- **Mitered Junctions**: Uses 2D polygon footprints + extrusion instead of overlapping boxes to prevent Z-fighting and ensure clean GLB exports.

## 4. Development Workflow

### File Structure
```
components/
├── editor/            # Canvas, tools, grid systems
├── nodes/             # Node implementations (Logic + Renderers)
│   └── [type]/        # e.g. wall/
│       ├── [type]-node.tsx      # Editor logic
│       └── [type]-renderer.tsx  # 3D Renderer
└── viewer/            # Read-only viewer components
lib/
├── scenegraph/        # Core graph logic & schemas
└── nodes/             # Registry & operations
```

### Adding a New Node Type
1.  **Define Schema**: Add Zod schema in `lib/scenegraph/schema/nodes/<type>.ts`.
2.  **Create Renderer**: Build `components/nodes/<type>/<type>-renderer.tsx`. Use `useEditor` selectors with `useShallow`.
3.  **Create Editor**: Build `components/nodes/<type>/<type>-node.tsx`. Handle `grid:click` / `grid:move` events.
4.  **Register**: Export and register in `components/nodes/index.ts`.

### Best Practices
- **Mutations**: Never mutate state directly. Use `handle.update()` or `store.addNode()`.
- **Previews**: Use `editor: { preview: true }` for temporary nodes (excluded from Undo/Redo).
- **Selectors**: Create specific, memoized selectors for renderers to avoid unnecessary re-renders.
- **Type Safety**: Use `SceneNodeHandle<NodeType>` for typed access.

## 5. Key Workflows

### Building Mode
- **Wall Placement**: Click start → hover preview → click end. Auto-commits to store.
- **Tools**: Selecting a tool auto-switches `controlMode` to `building`.
- **Previews**: Visualized in green (valid) or red (invalid).

### View Modes
- **Editor**: Full interactivity. Active floor is fully opaque; others are muted/transparent.
- **Viewer**: Read-only. Support for "Exploded" view (levels separated vertically) and "Stacked" view.

### Persistence
- **Storage**: JSON format. `use-editor.tsx` handles hydration/dehydration.
- **Assets**: Large files (reference images) are split into a separate IndexedDB key to keep the main state lightweight.
