# Building Editor - Project Documentation

## Overview

3D building/floor plan editor built with Next.js, React Three Fiber, and Zustand. Users create multi-floor layouts by placing walls/doors/windows/roofs on a grid, similar to The Sims build mode. Includes read-only **Viewer mode** for presentation.

## Technology Stack

### Core
- **Next.js 16** (App Router) with **React 19** and **TypeScript**
- **Bun** for package management

### 3D Rendering
- **Three.js** + **React Three Fiber (R3F)** - Declarative 3D scene management
- **@react-three/drei** - Camera controls, helpers, environment presets
- **@react-spring/three** - Smooth physics-based animations

### State & Persistence
- **Zustand** - Lightweight store with localStorage persistence, undo/redo stacks
- **IndexedDB** - Large file storage (reference images)

### UI & Styling
- **Tailwind CSS 4** - Utility-first styling
- **Shadcn UI** + **Radix UI** - Accessible component primitives
- **Lucide/Phosphor Icons**

### Development
- **Biome** - Fast linting/formatting
- **React Scan** - Performance monitoring

## Project Structure

```
app/
├── (editor)/          # Editor route with sidebar
└── viewer/            # Read-only viewer route

components/
├── editor/            # Editor canvas, tools, grid systems, controls
│   └── elements/      # 3D building elements (walls, doors, windows, roofs)
├── viewer/            # Viewer canvas and controls (read-only variants)
├── ui/                # Shadcn/Radix UI components
└── layers-menu.tsx    # Floor/layer management

hooks/
└── use-editor.tsx     # Zustand store (main state)

lib/                   # Type definitions, utilities, validation logic
public/models/         # 3D models (GLB)
```

## Development

```bash
bun install            # Install dependencies
bun dev                # Start dev server (Turbopack HMR)
bun run build          # Production build
bun run lint           # Format with Biome
```

## Grid System

### Architecture
**Discrete intersection-based placement** (61×61 grid points, 50cm spacing) rather than continuous placement. Grid coordinates map to world coordinates (Grid Y → World Z).

### Grid Types
- **Infinite Grid**: Base floor, shader-based, fades with distance
- **Proximity Grid**: Upper floors, dynamic bounds around elements
- **Interactive Grid Tiles**: Single raycasting plane for click detection

### Interaction
- Raycasting from camera through cursor to grid plane
- Smart snapping to horizontal/vertical/45° axes
- Visual previews (green for build, red for delete)
- Multi-floor support (stacked vs. exploded modes)

### Performance
- Single raycasting plane (not per-intersection meshes)
- Shader-based infinite grid (no geometry)
- Memoized components, conditional rendering

## Core Architecture

### Wall Geometry
**Mitered junctions** using 2D polygon footprints + extrusion (vs. overlapping boxes) - eliminates Z-fighting, enables GLB export. Junction detection + miter point calculation for clean wall intersections.

### Coordinate System
- Grid coordinates (integer) → World coordinates (float)
- Grid Y → World Z (ground plane)
- Parent group offset `[-15, 0, -15]` centers grid at origin

## Node-based Architecture

The canonical model is a typed node tree per level.

- **Root**: `levels: LevelNode[]` (one tree per floor)
- **Types** (`lib/nodes/types.ts`): `level`, `wall`, `door`, `window`, `column`, `roof`, `roof-segment`, `reference-image`, `scan`, `group`
- **Grid nodes**: `position [x,y]` (grid units), `rotation` (radians), `size [width, depth]`
  - Wall: `size = [length, thickness]` (thickness defaults to 0.2m)
  - Roof segment: adds `height`, `leftWidth`, `rightWidth`
- **Parent/child rules** (`lib/nodes/guards.ts`):
  - Level → wall | roof | column | reference-image | scan | group
  - Wall → door | window
  - Roof → roof-segment
  - Group → building elements | group
- **Invariants**:
  - IDs unique across the tree
  - Child `parent` equals parent's `id`
  - No cycles; `validateNodeTree` passes
  - `opacity` in 0–100; `visible`/`locked` booleans
  - All mutations are immutable (new arrays/objects)

APIs
- **Operations** (`lib/nodes/operations.ts`): pure add/move/update/delete (e.g., `addWallToLevel`, `addDoorToWall`, `moveNodeToParent`, `replaceWallsInLevel`)
- **Selectors** (`lib/nodes/selectors.ts`): ergonomic queries for levels, walls, doors/windows, visibility, counts, and memoizable builders
- **Indexes** (`lib/nodes/indexes.ts`): `NodeIndexes` for O(1) by-id/type/parent lookups and level mapping
- **Utils** (`lib/nodes/utils.ts`): traversal (`traverseTree`, `mapTree`), search (`findNodeById`, `findNodesByType`), structure ops (`addNode`, `updateNode`, `moveNode`)
- **Guards** (`lib/nodes/guards.ts`): runtime guards (`isWallNode`, `canBeChildOf`, `validateNodeTree`)

Performance
- Rebuild a minimal `nodeIndex: Map<string, BaseNode>` via `buildNodeIndex(levels)` after mutations
- For heavy queries, maintain `indexes: NodeIndexes` via `buildNodeIndexes(levels)` and use `getNodeById`, `getNodesByType`, `getChildrenOfNode`
- Prefer index-backed selectors in render paths (`selectNodeByIdFromIndex`)

## State Management

### Zustand Store (`hooks/use-editor.tsx`)
Single source of truth with localStorage persistence, undo/redo (snapshots of `levels`).

**Core State**:
- `levels: LevelNode[]` (canonical)
- `nodeIndex: Map<string, BaseNode>` (fast by-id, rebuild on mutation)
- `indexes?: NodeIndexes` (optional full indexes for large scenes)
- `selectedLevelId: string | null`
- `controlMode` - 'select' | 'delete' | 'building' | 'guide'
- `viewMode` / `levelMode` / `cameraMode`

**Mutations**:
- Use `lib/nodes/operations.ts` (pure) to produce new `levels`
- Immediately rebuild `nodeIndex` (and `indexes` if used)

**Queries**:
- Use `lib/nodes/selectors.ts` (e.g., `selectWallsFromLevel`, `selectDoorsFromLevel`)
- Prefer `selectNodeByIdFromIndex`/`createSingleNodeSelector` in render paths

### Editor Canvas
Multi-floor rendering with per-floor positioning. Active floor gets interactive grid + full colors, inactive floors are muted. Keyboard shortcuts for modes (V/D/B/G), undo (Cmd+Z), camera (Space).

### Viewer Mode
Read-only presentation mode. Reuses editor components with no-op handlers. Animated floor transitions (stacked ↔ exploded), camera modes (perspective ↔ orthographic), click-to-focus floors, visibility toggles. Keyboard: C (camera), L (levels), Esc (deselect).

### UI & Controls
- **Mode Menu**: Select/Delete/Building/Guide modes, color-coded
- **Building Menu**: Tool selection, auto-switches to building mode
- **Camera Controls**: Mode-aware mouse bindings - left-click for panning (select mode) or tool actions (other modes)
- **Reference Images**: 3D manipulation handles in Guide mode (translate, rotate, scale)

## Key Workflows

### Building
- **Wall Placement**: Click start → hover preview → click end → auto-save to store
- **Deletion**: Click wall + right-click menu (select mode), or two-click line selection (delete mode)
- **Reference Images**: Upload → position/rotate/scale with 3D handles in Guide mode

### Modes
- Tool selection auto-switches to building mode
- Esc/mode change clears placement states
- Building logic isolated to building mode

### Persistence
- Auto-sync to localStorage via Zustand
- JSON export/import for layouts
- Undo/redo stacks (max 50 states)

## Design Decisions

### Sims-Inspired Choices
- **Multi-Mode System**: Separate Select/Delete/Building modes (like The Sims) vs. single mode with modifiers - clearer mental model
- **Intersection-Based Walls**: Line segments between grid points vs. tile fills - supports diagonals, matches real blueprints, cleaner state
- **Smart Snapping**: Auto-snaps to H/V/45° axes - prevents messy off-axis walls, matches Sims behavior
- **Visual Previews**: Green shadows for placement, red planes for deletion - see before committing, reduces mistakes
- **Isometric View**: Camera at [10,10,10] polar 0-π/2 - classic Sims-style overhead perspective
- **Viewer Mode**: Read-only presentation mode (like Sims camera mode) - showcase finished designs without editing

### Technical Choices
- **Zustand Over Context**: Better performance, built-in persistence, simpler API, undo/redo via stacks
- **Geometric Deletion**: Line overlap detection - precisely cut/remove wall portions (like Sims demolish tool)
- **Drei Grid + Custom Raycasting**: Drei for visuals, custom plane for clicks - Drei Grid is visual-only
- **Memoized Components**: React.memo on GridTiles/Walls/Previews - smooth 60fps with hundreds of walls
- **HTML Context Menu**: Overlay div vs. R3F component - reliable pointer coords
- **Keyboard Shortcuts**: V/D/B/G/Esc/Space/Z (editor), C/L/Esc (viewer) - CAD/Sims-inspired power user workflow
- **Versioned JSON**: Schema v2.0 with segment-based format - extensible for doors/windows/furniture
- **Direct Manipulation Handles**: 3D gizmos for reference images - raycasting + pointer events for intuitive transformations, handles scale inversely to image scale for consistent size
- **Mode-Aware Camera Controls**: Dynamic mouse button configuration - left-click reserved for mode actions (delete/build/guide) vs. camera panning (select), prevents conflicts between camera and tool interactions
- **Mitered Wall Geometry**: 2D polygon footprints + extrusion vs. overlapping boxes - eliminates Z-fighting, supports proper GLB export, enables future wall features (cutouts, materials)
- **Animated Transitions**: React Spring for smooth floor separation - enhances UX in viewer mode

## Data Model

### Canonical (nodes v2.0)
- `levels: LevelNode[]` with typed children per `lib/nodes/types.ts`
- Grid units = 0.5m; rotations in radians
- Doors/windows live under their parent `wall`; roof segments under `roof`
- Supports indexing (`lib/nodes/indexes.ts`) and validation (`validateNodeTree`)

### Legacy compatibility (components v1.x)
- Migration utilities in `lib/migration/`:
  - `legacy-to-nodes.ts`: `componentsToNodeTree`, `associateDoorsAndWindowsWithWalls`
  - `nodes-to-legacy.ts`: `nodeTreeToComponents(WithLevels)`
  - `validators.ts`: integrity checks and round-trip validation
- Use migrations only at import/export boundaries; keep editor logic node-native

### Persistence
- Auto-sync to localStorage via Zustand middleware
- JSON export/import (`layout_YYYY-MM-DD.json`)
- Viewer loads from localStorage (edit in main editor)

## Contributing to the Node Model

- **Add a new node type**
  1) Define in `lib/nodes/types.ts`
  2) Add guards and `canBeChildOf` in `lib/nodes/guards.ts`
  3) Add operations/selectors as needed
  4) Render in editor/viewer layers
  5) Update migrations if represented in legacy format

- **Do’s**
- Prefer `operations.ts` over ad-hoc tree manipulation
- Recompute `nodeIndex`/`indexes` after each mutation
- Use selectors with shallow comparison in React

- **Don’ts**
- Don’t mutate nodes in place
- Don’t traverse entire trees in hot render paths; use indexes/selectors
