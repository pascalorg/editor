### Objective and vision

- Build a Sims‑style building engine that is easy to extend, API‑native, and performant.
- Preserve today’s UX and features while introducing an engine (ECS‑like) runtime to centralize generic logic: bounds, footprints, snapping, and future physics.
- Keep `lib/nodes/` as the canonical, persisted authoring model (undo/redo, invariants, validation). The engine is a derived runtime used by renderers and tools.
- Make adding elements trivial and “spec‑first”: built‑ins and remote catalog items integrate the same way.

### Non‑goals

- No breaking changes to existing behavior, tools, or file formats.
- Do not remove or replace the node tree; it remains the source of truth.

## Architecture overview

- **Nodes (canonical)**: `lib/nodes/` — types, guards, operations, selectors, indexes, validation, persistence.
- **Engine (runtime)**: `lib/engine/` — ECS‑style world derived from nodes; systems compute generic behavior.
- **Spec‑first**: both built‑ins and online catalog items register via the same Element Spec at runtime.

### Data flow

- Node operation updates `levels` → build/refresh engine world → run systems (bounds, footprints, surfaces, snapping) → UI/renderers consume engine data. Existing node selectors remain usable.

## Minimal node‑layer additions (one‑time)

- `lib/nodes/extensions.ts` (new): registry for parent/child rules of custom (dynamic) types.
- `lib/nodes/guards.ts` (tiny edit): in `canBeChildOf(child, parent)`, if built‑in rules don’t match, fall back to `extensions.canTypeBeChildOf(child.type, parent.type)`.
- `lib/nodes/selectors.ts` (addition): `selectNodesByTypeString(type: string)` to query dynamic types without touching unions.
- No ongoing edits to `types.ts` when introducing new element types.

## Engine layout (additions)

- `lib/engine/`
  - `core.ts` — World, EntityId, component stores, simple queries
  - `components.ts` — `TransformGrid`, `Visibility`, `ElementTag`, `Bounds`, `Footprint`, `Surface`, `Socket`, `SnapBehavior`, `Attachment`
  - `registry.ts` — `ElementDefinition`, `register/get/all`
  - `spec.ts` — ElementSpec (JSON‑friendly schema + TS types)
  - `spec-registry.ts` — `registerFromSpec(spec)` → plugs a spec into the engine
  - `strategies/` — `bounds.ts`, `footprint.ts`, `snap.ts` (pure strategy tables)
  - `systems/` — `bounds`, `footprint` (mitered walls), `surfaces`, `snap-targets`, `snap-eval`, `occupancy`, `physics` (stub)
  - `adapters/nodes-to-world.ts` — builds World from `levels`
  - `builtin-specs/` — local specs for wall/door/window/etc.
  - `register-builtins.ts` — registers built‑ins via `registerFromSpec`
  - `runtime-catalog.ts` — fetches remote specs and registers at runtime
  - `index.ts` — public exports
- `hooks/use-engine.ts` — memoizes world from `levels` and runs systems
- `components/editor/elements/catalog-item-mesh.tsx` — generic renderer for spec‑defined items (GLB or footprint extrusion)

## Element Spec (API‑native, used by built‑ins and remote)

```ts
export type BoundsStrategy = 'orientedRectFromSize' | 'aabbFromModelXY' | 'convexHullFromModelXY'
export type FootprintStrategy = 'rectFromSize' | 'polygon' | 'hullFromModelXY'

export interface ElementSpec {
  schemaVersion: '1.0'
  type: string
  label: string
  category?: string
  node: { gridItem: boolean; defaults?: { size_m?: [number,number]; rotation_rad?: number }; parentRules?: string[] }
  render?: { model?: { url: string; scale?: number; upAxis?: 'Y'|'Z' }; anchor?: 'center'|'back'|'front'|'left'|'right' }
  bounds?: { strategy: BoundsStrategy }
  footprint?: { strategy: FootprintStrategy; polygon?: Array<[number,number]> }
  snap?: {
    gridStep_m?: number
    allowedAngles_rad?: number[]
    anchors?: Array<{ name: string; offset_m: [number,number,number] }>
    targets?: Array<'gridFloor'|'wallMount'|'ceilingHang'|'stackOnto'|'free'>
    radius_m?: number
    priority?: Array<'socket'|'surface'|'wallLine'|'gridPoint'>
    masks?: number
  }
  sockets?: Array<{
    type: 'surface.top'|'wall.mount'|'ceiling.hang'
    localPose: { position_m: [number,number,number]; rotationY_rad?: number }
    capacity?: number
    mask?: number
  }>
  physics?: { shape?: 'box'|'mesh'; mass?: number }
  parameters?: Array<{ key:string; type:'number'|'enum'|'bool'; default?: any; mapsTo?: string }>
  version?: string
  vendor?: string
}
```

### Spec → Engine definition (single registration path)

```ts
// registerFromSpec(spec)
register({
  type: spec.type,
  create(node, ctx) {
    const size = node.size ?? metersToGrid(spec.node.defaults?.size_m ?? [1,1], ctx.gridSizeMeters)
    return {
      TransformGrid: { position: node.position, rotation: node.rotation ?? (spec.node.defaults?.rotation_rad ?? 0), size },
      Visibility: { visible: node.visible ?? true, opacity: node.opacity ?? 100 },
      Element: { kind: spec.type, name: node.name, metadata: { spec } },
      Snap: {
        gridStep: metersToGrid(spec.snap?.gridStep_m ?? 0.5, ctx.gridSizeMeters),
        allowedAngles: spec.snap?.allowedAngles_rad ?? [0, Math.PI/4, Math.PI/2],
        custom: { anchors: spec.snap?.anchors, targets: spec.snap?.targets, masks: spec.snap?.masks },
        radius: metersToGrid(spec.snap?.radius_m ?? 1.0, ctx.gridSizeMeters),
        priority: spec.snap?.priority ?? ['socket','surface','wallLine','gridPoint'],
      },
    }
  },
  computeBounds: (id, w) => boundsFromStrategy(spec.bounds?.strategy ?? 'orientedRectFromSize', id, w),
  computeFootprint: (id, w) => footprintFromStrategy(spec.footprint?.strategy ?? 'rectFromSize', id, w, spec),
})

// parent rules (nodes):
registerNodeTypeExtension(spec.type, { canBeChildOf: (p) => spec.node.parentRules?.includes(p) ?? false })
```

## Systems (concise)

- **BoundsSystem**: per‑entity bounds from `TransformGrid` (handles roof segment widths).
- **FootprintSystem**: mitered wall polygons; other elements via rectangle/polygon/hull strategies.
- **SurfacesSystem**: derive `floorTop`, `ceilingBottom`, `wallFace`, `roofFace` from geometry.
- **SnapTargetsSystem**: convert surfaces/sockets/grid points/wall centerlines into queryable targets with bitmasks.
- **SnapIndexSystem**: spatial index (KD‑tree/RBush) by level; fast candidate lookup.
- **SnapEvalSystem**: during placement, filter by masks/targets; score by distance, angle, priority, occupancy; output `Attachment` pose.
- **OccupancySystem**: 2D OBB/polygon overlap and socket capacity checks.
- **PhysicsSystem (stub)**: future integration; will update `TransformGrid` from bodies.

## Snapping model (inspired by Sims/Unity/Unreal)

- Surfaces: `floorTop`, `ceilingBottom`, `wallFace`, `roofFace` derived from footprints/walls.
- Targets: surfaces, sockets, wall lines, grid points; indexed and masked.
- Behavior: per‑element `SnapBehavior` in spec controls grid step, angle locks, anchors/offsets, allowed targets, search radius, priority order.
- Placement: pick best target → compute pose (position + `rotationY`) and apply anchor/offsets; prevent overlaps.

## Built‑ins declared like remote specs

```ts
export const WallSpec: ElementSpec = {
  schemaVersion: '1.0',
  type: 'core.wall',
  label: 'Wall',
  node: { gridItem: true, defaults: { size_m: [1, 0.2] }, parentRules: ['level','group'] },
  bounds: { strategy: 'orientedRectFromSize' },
  footprint: { strategy: 'rectFromSize' },
  snap: { gridStep_m: 0.5, allowedAngles_rad: [0, Math.PI/4, Math.PI/2], targets: ['gridFloor','wallMount'] },
}
```

## Adding a new element (built‑in or remote)

- Provide a Spec with `type`, `node`, `render`, `bounds`, `footprint`, `snap`, optional `sockets`.
- Call `registerFromSpec(spec)` (built‑ins via `register-builtins.ts`; remote via `runtime-catalog.ts`).
- Renderer: generic `CatalogItemMesh` loads GLB if specified, else extrudes `Footprint`.
- No edits to `types.ts`; parent rules flow through `extensions.ts`.

## Hooks and rendering

- `useEngineWorld()` memoizes world from `levels` and runs systems.
- `CatalogItemMesh` consumes `TransformGrid`/`Visibility` and spec metadata to render GLB or footprint extrusion.
- Existing components can progressively switch to engine‑derived data while preserving current behavior.

## Online catalog

- `runtime-catalog.ts` loads `GET /catalog` and `GET /catalog/:id/spec` (JSON), validates, then `registerFromSpec(spec)`.
- Models served from allowlisted origins; cache by version. Validate and clamp parameters.
- Nodes persist `type` and parameters in metadata; engine reconstructs behavior on load.

## Rollout (phased, no feature changes)

1) Engine scaffold + BoundsSystem + `useEngineWorld`.
2) Built‑ins as specs; switch camera framing to engine bounds.
3) Extract wall mitering → FootprintSystem; `Walls` consume engine footprints.
4) Surfaces + snap targets + evaluation; tools use engine snapping.
5) Online catalog loader; generic catalog renderer.
6) Physics stubs and future integration.

## Acceptance criteria

- Feature parity: visuals and interactions unchanged.
- Nodes invariants preserved (`validateNodeTree`, guards, operations, indexes).
- Equal or better performance for bounds and wall rendering.
- New elements added by registering a spec; no edits to `types.ts`; only additive changes elsewhere.

## Testing

- Spec validation (schema + constraints).
- Adapter: nodes → world entities/components.
- Systems: bounds parity with current logic; footprint mitering (T/L/X junctions); snapping correctness per target class; occupancy correctness.
- Smoke tests: import demo scene, render walls/doors/windows/roofs; selection works; placement snaps as before; undo/redo consistent.

